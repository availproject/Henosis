use ark_ec::{AffineCurve, ProjectiveCurve};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::Result;
use ark_bn254::{g1, g1::Parameters, Bn254, FqParameters, Fr, FrParameters, G1Projective};
use ark_ec::short_weierstrass_jacobian::GroupAffine;
use ark_ff::{Field, Fp256, Fp256Parameters, One, PrimeField, UniformRand, Zero};
use bincode;
use ::bonsai_sdk::alpha::responses::SnarkReceipt;
use bonsai_sdk::alpha as bonsai_sdk;
use fflonk_verifier::utils::{G1Point, Proof};
use hex;
use zkevmguest::{VERIFIER_ELF, VERIFIER_ID};
use zksyncguest::{ZKSYNCGUEST_ELF, ZKSYNCGUEST_ID};
use risc0_zkvm::{compute_image_id, serde::to_vec, Receipt, ExecutorEnv, default_prover};
use std::fmt::{Debug, DebugMap, Display};
use std::marker::PhantomData;
use std::ops::{Add, Mul, Neg, Sub};
use std::str::FromStr;
use std::time::{Duration, Instant};
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;

#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
struct ProofInput {
    input: [Vec<String>; 1],
    signal: [String; 1]
}

pub fn convert_fflonk_to_stark(pr_updated: [Vec<String>; 1], signal: [String; 1]) -> Receipt {
    println!("Converter: {:?}", pr_updated);

    let proof_input = ProofInput {
        input: pr_updated,
        signal
    };

    // to run recursive proving locally

    // let env = ExecutorEnv::builder()
    // .write(&proof_input)
    // .unwrap()
    // .build()
    // .unwrap();

    // let receipt = default_prover().prove(env, VERIFIER_ELF).unwrap();
    // receipt.verify(VERIFIER_ID).unwrap();
    // receipt

    // recursive proving outsourced using bonsai
    let url = "https://api.bonsai.xyz/".to_string();
    let api_key = "API_KEY".to_string();
    let client = bonsai_sdk::Client::from_parts(url, api_key, risc0_zkvm::VERSION)
        .expect("Failed to construct sdk client");
    println!("Reached here");

    let image_id = hex::encode(compute_image_id(VERIFIER_ELF).unwrap());
    println!("Image ID done: {}", image_id);
    client.upload_img(&image_id, VERIFIER_ELF.to_vec()).unwrap();

    println!("Image ID: {}", image_id);

    let input_data = to_vec(&proof_input).unwrap();
    let input_data = bytemuck::cast_slice(&input_data).to_vec();
    let input_id = client.upload_input(input_data).unwrap();
    let final_receipt: Receipt;

    let assumptions: Vec<String> = vec![];

    let proving_and_conversion_start_time = Instant::now();

    let session = client.create_session(image_id, input_id, assumptions).unwrap();
    loop {
        let res = session.status(&client).unwrap();
        if res.status == "RUNNING" {
            eprintln!(
                "Current status: {} - state: {} - continue polling...",
                res.status,
                res.state.unwrap_or_default()
            );
            std::thread::sleep(Duration::from_secs(15));
            continue;
        }
        if res.status == "SUCCEEDED" {
            // Download the receipt, containing the output
            let receipt_url = res
                .receipt_url
                .expect("API error, missing receipt on completed session");

            let receipt_buf = client.download(&receipt_url).unwrap();
            let receipt: Receipt = bincode::deserialize(&receipt_buf).unwrap();
            final_receipt = receipt.clone();

            // code to serialize and save
            // let mut file = File::create("stark.bin").unwrap();
            // let mut another_file = File::create("stark2.txt").unwrap();
            
            // Write the byte data to the file
            // file.write_all(&receipt_buf).unwrap();
            // another_file.write_all(&receipt_buf).unwrap();
            // println!("Journal: {:?}", receipt.journal);

            receipt
                .verify(VERIFIER_ID)
                .expect("Receipt verification failed");
        } else {
            panic!(
                "Workflow exited: {} - | err: {}",
                res.status,
                res.error_msg.unwrap_or_default()
            );
        }

        break;
    }

    // let snark_session = client.create_snark(session.uuid).unwrap();
    // eprintln!("Created snark session: {}", snark_session.uuid);

    // let mut snark_receipt_resp: SnarkReceipt;
    // loop {
    //     let res: bonsai_sdk::responses::SnarkStatusRes = snark_session.status(&client).unwrap();
    //     match res.status.as_str() {
    //         "RUNNING" => {
    //             eprintln!("Current status: {} - continue polling...", res.status,);
    //             std::thread::sleep(Duration::from_secs(15));
    //             continue;
    //         }
    //         "SUCCEEDED" => {
    //             let snark_receipt = res.output;
    //             eprintln!("Snark proof!: {snark_receipt:?}");
    //             snark_receipt_resp = snark_receipt.unwrap();
    //             // return snark_receipt?;
    //             break;
    //         }
    //         _ => {
    //             panic!(
    //                 "Workflow exited: {} err: {}",
    //                 res.status,
    //                 res.error_msg.unwrap_or_default()
    //             );
    //         }
    //     }
    // }

    let proving_and_conversion_end_time = Instant::now();
    let elapsed_time = proving_and_conversion_end_time.duration_since(proving_and_conversion_start_time);
    println!(
        "Time for recursive proving of zkevm proof {:?}",
        elapsed_time.as_secs_f64()
    );

    final_receipt
}

// for now we are hardcoding mplonk proof
pub fn convert_mplonk_to_stark() -> Receipt {
    let url = "https://api.bonsai.xyz/".to_string();
    let api_key = "API_KEY".to_string();
    let client = bonsai_sdk::Client::from_parts(url, api_key, risc0_zkvm::VERSION)
        .expect("Failed to construct sdk client");
    println!("Reached here");

    let image_id = hex::encode(compute_image_id(ZKSYNCGUEST_ELF).unwrap());
    println!("Image ID done: {}", image_id);

    let sample_input: u32 = 1;

    let input_data = to_vec(&sample_input).unwrap();
    let input_data = bytemuck::cast_slice(&input_data).to_vec();
    let input_id = client.upload_input(input_data).unwrap();
    
    client.upload_img(&image_id, ZKSYNCGUEST_ELF.to_vec()).unwrap();

    println!("Image ID: {}", image_id);

    let final_receipt: Receipt;

    let assumptions: Vec<String> = vec![];

    let proving_and_conversion_start_time = Instant::now();

    let session = client.create_session(image_id, input_id, assumptions).unwrap();
    loop {
        let res = session.status(&client).unwrap();
        if res.status == "RUNNING" {
            eprintln!(
                "Current status: {} - state: {} - continue polling...",
                res.status,
                res.state.unwrap_or_default()
            );
            std::thread::sleep(Duration::from_secs(15));
            continue;
        }
        if res.status == "SUCCEEDED" {
            let receipt_url = res
                .receipt_url
                .expect("API error, missing receipt on completed session");

            let receipt_buf = client.download(&receipt_url).unwrap();
            let receipt: Receipt = bincode::deserialize(&receipt_buf).unwrap();
            final_receipt = receipt.clone();

            // code to serialize and save
            // let mut file = File::create("stark.bin").unwrap();
            // let mut another_file = File::create("stark2.txt").unwrap();
            
            // Write the byte data to the file
            // file.write_all(&receipt_buf).unwrap();
            // another_file.write_all(&receipt_buf).unwrap();
            // println!("Journal: {:?}", receipt.journal);

            receipt
                .verify(ZKSYNCGUEST_ID)
                .expect("Receipt verification failed");
        } else {
            panic!(
                "Workflow exited: {} - | err: {}",
                res.status,
                res.error_msg.unwrap_or_default()
            );
        }

        break;
    }

    let proving_and_conversion_end_time = Instant::now();
    let elapsed_time = proving_and_conversion_end_time.duration_since(proving_and_conversion_start_time);
    println!(
        "Time for recursive proving of zkevm proof {:?}",
        elapsed_time.as_secs_f64()
    );

    final_receipt

}